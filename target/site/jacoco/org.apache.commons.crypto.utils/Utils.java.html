<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Crypto</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.crypto.utils</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.crypto.utils;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Properties;

import org.apache.commons.crypto.cipher.Cipher;
import org.apache.commons.crypto.cipher.CipherFactory;
import org.apache.commons.crypto.cipher.CipherTransformation;

import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_STREAM_BUFFER_SIZE_DEFAULT;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_STREAM_BUFFER_SIZE_KEY;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_CIPHER_CLASSES_DEFAULT;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_CIPHER_CLASSES_KEY;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_CIPHER_JCE_PROVIDER_KEY;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_LIB_NAME_KEY;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_LIB_PATH_KEY;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_SECURE_RANDOM_DEVICE_FILE_PATH_DEFAULT;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_SECURE_RANDOM_DEVICE_FILE_PATH_KEY;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_SYSTEM_PROPERTIES_FILE;
import static org.apache.commons.crypto.conf.ConfigurationKeys.CHIMERA_CRYPTO_LIB_TEMPDIR_KEY;

/**
 * General utility methods.
 */
<span class="nc" id="L48">public class Utils {</span>
  private static final int MIN_BUFFER_SIZE = 512;

<span class="fc" id="L51">  protected static final CipherTransformation AES_CTR_NOPADDING = CipherTransformation.AES_CTR_NOPADDING;</span>

  /**
   * For AES, the algorithm block is fixed size of 128 bits.
   * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard
   */
<span class="fc" id="L57">  private static final int AES_BLOCK_SIZE = AES_CTR_NOPADDING.getAlgorithmBlockSize();</span>

  static {
<span class="fc" id="L60">    loadChimeraSystemProperties();</span>
<span class="fc" id="L61">  }</span>

  /**
   * loads system properties when configuration file of the name
   * {@link #CHIMERA_SYSTEM_PROPERTIES_FILE} is found.
   */
  private static void loadChimeraSystemProperties() {
    try {
<span class="fc" id="L69">      InputStream is = Thread.currentThread().getContextClassLoader()</span>
          .getResourceAsStream(CHIMERA_SYSTEM_PROPERTIES_FILE);

<span class="pc bpc" id="L72" title="1 of 2 branches missed.">      if (is == null)</span>
<span class="fc" id="L73">        return; // no configuration file is found</span>

      // Load property file
<span class="nc" id="L76">      Properties props = new Properties();</span>
<span class="nc" id="L77">      props.load(is);</span>
<span class="nc" id="L78">      is.close();</span>
<span class="nc" id="L79">      Enumeration&lt;?&gt; names = props.propertyNames();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      while (names.hasMoreElements()) {</span>
<span class="nc" id="L81">        String name = (String) names.nextElement();</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (name.startsWith(&quot;chimera.&quot;)) {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">          if (System.getProperty(name) == null) {</span>
<span class="nc" id="L84">            System.setProperty(name, props.getProperty(name));</span>
          }
        }
<span class="nc" id="L87">      }</span>
<span class="nc" id="L88">    } catch (Throwable ex) {</span>
<span class="nc" id="L89">      System.err.println(&quot;Could not load '&quot;</span>
          + CHIMERA_SYSTEM_PROPERTIES_FILE + &quot;' from classpath: &quot;
          + ex.toString());
<span class="nc" id="L92">    }</span>
<span class="nc" id="L93">  }</span>

  /**
   * Forcibly free the direct buffer.
   *
   * @param buffer the bytebuffer to be freed.
   */
  public static void freeDirectBuffer(ByteBuffer buffer) {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">    if (buffer instanceof sun.nio.ch.DirectBuffer) {</span>
<span class="fc" id="L102">      final sun.misc.Cleaner bufferCleaner =</span>
          ((sun.nio.ch.DirectBuffer) buffer).cleaner();
<span class="fc" id="L104">      bufferCleaner.clean();</span>
    }
<span class="fc" id="L106">  }</span>

  /**
   * Reads crypto buffer size.
   *
   * @param props The &lt;code&gt;Properties&lt;/code&gt; class represents a set of
   *              properties.
   * @return the buffer size.
   * */
  public static int getBufferSize(Properties props) {
<span class="nc" id="L116">    String bufferSizeStr = props.getProperty(</span>
        CHIMERA_CRYPTO_STREAM_BUFFER_SIZE_KEY);
<span class="nc bnc" id="L118" title="All 4 branches missed.">    if (bufferSizeStr == null || bufferSizeStr.isEmpty()) {</span>
<span class="nc" id="L119">      bufferSizeStr = System</span>
        .getProperty(CHIMERA_CRYPTO_STREAM_BUFFER_SIZE_KEY);
    }
<span class="nc bnc" id="L122" title="All 4 branches missed.">    if (bufferSizeStr == null || bufferSizeStr.isEmpty()) {</span>
<span class="nc" id="L123">      return CHIMERA_CRYPTO_STREAM_BUFFER_SIZE_DEFAULT;</span>
    } else {
<span class="nc" id="L125">      return Integer.parseInt(bufferSizeStr);</span>
    }
  }

  /**
   * Gets the cipher class.
   *
   * @param props The &lt;code&gt;Properties&lt;/code&gt; class represents a set of
   *              properties.
   * @return the cipher class based on the props.
   */
  public static String getCipherClassString(Properties props) {
<span class="fc" id="L137">    final String configName = CHIMERA_CRYPTO_CIPHER_CLASSES_KEY;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    return props.getProperty(configName) != null ? props.getProperty(configName) : System</span>
        .getProperty(configName, CHIMERA_CRYPTO_CIPHER_CLASSES_DEFAULT);
  }

  /**
   * Gets the Jce provider.
   *
   * @param props The &lt;code&gt;Properties&lt;/code&gt; class represents a set of
   *              properties.
   * @return the jce provider based on the props.
   */
  public static String getJCEProvider(Properties props) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    return props.getProperty(CHIMERA_CRYPTO_CIPHER_JCE_PROVIDER_KEY) != null ?</span>
        props.getProperty(CHIMERA_CRYPTO_CIPHER_JCE_PROVIDER_KEY) :
        System.getProperty(CHIMERA_CRYPTO_CIPHER_JCE_PROVIDER_KEY);
  }

  /**
   * Gets the random device path.
   *
   * @param props The &lt;code&gt;Properties&lt;/code&gt; class represents a set of
   *              properties.
   * @return the random device path based on the props.
   */
  public static String getRandomDevPath(Properties props) {
<span class="fc" id="L163">    String devPath = props.getProperty(</span>
        CHIMERA_CRYPTO_SECURE_RANDOM_DEVICE_FILE_PATH_KEY);
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">    if (devPath == null) {</span>
<span class="fc" id="L166">      devPath = System.getProperty(</span>
          CHIMERA_CRYPTO_SECURE_RANDOM_DEVICE_FILE_PATH_KEY,
          CHIMERA_CRYPTO_SECURE_RANDOM_DEVICE_FILE_PATH_DEFAULT);
    }
<span class="fc" id="L170">    return devPath;</span>
  }

  /**
   * Gets path of native library.
   *
   * @return the path of native library.
   */
  public static String getLibPath() {
<span class="fc" id="L179">    return System.getProperty(CHIMERA_CRYPTO_LIB_PATH_KEY);</span>
  }

  /**
   * Gets the file name of native library.
   *
   * @return the file name of native library.
   */
  public static String getLibName() {
<span class="fc" id="L188">    return System.getProperty(CHIMERA_CRYPTO_LIB_NAME_KEY);</span>
  }

  /**
   * Gets the temp directory for extracting crypto library.
   *
   * @return the temp directory.
   */
  public static String getTmpDir() {
<span class="fc" id="L197">    return System.getProperty(CHIMERA_CRYPTO_LIB_TEMPDIR_KEY,</span>
        System.getProperty(&quot;java.io.tmpdir&quot;));
  }

  /**
   * Checks whether the cipher is supported streaming.
   *
   * @param cipher the {@link org.apache.commons.crypto.cipher.Cipher} instance.
   * @throws IOException if an I/O error occurs.
   */
  public static void checkStreamCipher(Cipher cipher) throws IOException {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">    if (cipher.getTransformation() != CipherTransformation.AES_CTR_NOPADDING) {</span>
<span class="nc" id="L209">      throw new IOException(&quot;AES/CTR/NoPadding is required&quot;);</span>
    }
<span class="fc" id="L211">  }</span>

  /**
   * Checks and floors buffer size.
   *
   * @param cipher the {@link org.apache.commons.crypto.cipher.Cipher} instance.
   * @param bufferSize the buffer size.
   * @return the remaining buffer size.
   */
  public static int checkBufferSize(Cipher cipher, int bufferSize) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">    checkArgument(bufferSize &gt;= MIN_BUFFER_SIZE,</span>
        &quot;Minimum value of buffer size is &quot; + MIN_BUFFER_SIZE + &quot;.&quot;);
<span class="fc" id="L223">    return bufferSize - bufferSize % cipher.getTransformation()</span>
        .getAlgorithmBlockSize();
  }

  /**
   * This method is only for Counter (CTR) mode. Generally the Cipher calculates the
   * IV and maintain encryption context internally.For example a
   * {@link javax.crypto.Cipher} will maintain its encryption context internally
   * when we do encryption/decryption using the Cipher#update interface.
   * &lt;p/&gt;
   * Encryption/Decryption is not always on the entire file. For example,
   * in Hadoop, a node may only decrypt a portion of a file (i.e. a split).
   * In these situations, the counter is derived from the file position.
   * &lt;p/&gt;
   * The IV can be calculated by combining the initial IV and the counter with
   * a lossless operation (concatenation, addition, or XOR).
   * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_.28CTR.29
   *
   * @param initIV initial IV
   * @param counter counter for input stream position
   * @param IV the IV for input stream position
   */
  public static void calculateIV(byte[] initIV, long counter, byte[] IV) {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    checkArgument(initIV.length == AES_BLOCK_SIZE);</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">    checkArgument(IV.length == AES_BLOCK_SIZE);</span>

<span class="fc" id="L249">    int i = IV.length; // IV length</span>
<span class="fc" id="L250">    int j = 0; // counter bytes index</span>
<span class="fc" id="L251">    int sum = 0;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">    while (i-- &gt; 0) {</span>
      // (sum &gt;&gt;&gt; Byte.SIZE) is the carry for addition
<span class="fc" id="L254">      sum = (initIV[i] &amp; 0xff) + (sum &gt;&gt;&gt; Byte.SIZE);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">      if (j++ &lt; 8) { // Big-endian, and long is 8 bytes length</span>
<span class="fc" id="L256">        sum += (byte) counter &amp; 0xff;</span>
<span class="fc" id="L257">        counter &gt;&gt;&gt;= 8;</span>
      }
<span class="fc" id="L259">      IV[i] = (byte) sum;</span>
    }
<span class="fc" id="L261">  }</span>

  /**
   * Helper method to create a Cipher instance and throws only IOException.
   *
   * @param props The &lt;code&gt;Properties&lt;/code&gt; class represents a set of
   *              properties.
   * @param transformation the CipherTransformation instance.
   * @return the Cipher instance.
   * @throws IOException if an I/O error occurs.
   */
  public static Cipher getCipherInstance(CipherTransformation transformation,
      Properties props) throws IOException {
    try {
<span class="nc" id="L275">      return CipherFactory.getInstance(transformation, props);</span>
<span class="nc" id="L276">    } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L277">      throw new IOException(e);</span>
    }
  }

  /**
   * Ensures the truth of an expression involving one or more parameters to
   * the calling method.
   *
   * @param expression a boolean expression.
   * @throws IllegalArgumentException if expression is false.
   */
  public static void checkArgument(boolean expression) {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">    if(!expression) {</span>
<span class="nc" id="L290">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L292">  }</span>

  /**
   * Checks the truth of an expression.
   *
   * @param expression   a boolean expression.
   * @param errorMessage the exception message to use if the check fails;
   *                     will be converted to a string using &lt;code&gt;String
   *                     .valueOf(Object)&lt;/code&gt;.
   * @throws IllegalArgumentException if expression is false.
   */
  public static void checkArgument(boolean expression, Object errorMessage) {
<span class="fc bfc" id="L304" title="All 2 branches covered.">    if (!expression) {</span>
<span class="fc" id="L305">      throw new IllegalArgumentException(String.valueOf(errorMessage));</span>
    }
<span class="fc" id="L307">  }</span>

  /**
   * Ensures that an object reference passed as a parameter to the calling
   * method is not null.
   *
   * @param reference an object reference.
   * @return the non-null reference that was validated.
   * @throws NullPointerException if reference is null.
   */
  public static &lt;T&gt; T checkNotNull(T reference) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">    if(reference == null) {</span>
<span class="nc" id="L319">      throw new NullPointerException();</span>
    } else {
<span class="fc" id="L321">      return reference;</span>
    }
  }

  /**
   * Ensures the truth of an expression involving the state of the calling
   * instance, but not involving any parameters to the calling method.
   *
   * @param expression a boolean expression.
   * @throws IllegalStateException if expression is false.
   */
  public static void checkState(boolean expression) {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if(!expression) {</span>
<span class="nc" id="L334">      throw new IllegalStateException();</span>
    }
<span class="fc" id="L336">  }</span>

  /**
   * Splits class names sequence into substrings, Trim each substring into an
   * entry,and returns an list of the entries.
   *
   * @param clazzNames a string consist of a list of the entries joined by a
   *                   delimiter.
   * @param separator  a delimiter for the input string.
   * @return a list of class entries.
   */
  public static List&lt;String&gt; splitClassNames(String clazzNames,
      String separator) {
<span class="fc" id="L349">    List&lt;String&gt; res = new ArrayList&lt;String&gt;();</span>
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">    if (clazzNames == null || clazzNames.isEmpty()) {</span>
<span class="fc" id="L351">      return res;</span>
    }

<span class="fc bfc" id="L354" title="All 2 branches covered.">    for (String clazzName : clazzNames.split(separator)) {</span>
<span class="fc" id="L355">      clazzName = clazzName.trim();</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">      if (!clazzName.isEmpty()) {</span>
<span class="fc" id="L357">        res.add(clazzName);</span>
      }
    }
<span class="fc" id="L360">    return res;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>